28/10/2025
----------
Types of function 
1. Inbuilt function
2. User Defined function
-------------------------

Built in --> 
1. abs()
    It ignores the negative part of the value
    it does not convert it ignores
2. all()
    #return value of all() function
     when the values inside the list are all true then it will print true
     0 is a false number
     an empty list is also considered true
     if(false,1,2)---> in case = false 
3. dir()
    #directory..
    there is given list of numbers ,the number of operation that can be done on it ---that same directory is returned
4. divmod()
    Given two numbers and then returns the pair as(qoitient, reminder)
    print(divmod(9,2))
5. enumerate()
    using this you  can start the indexing from anywhere 
    used in the leader board making 
6. filter()
   conditionally apply the filter to get the rquired output
7. isinstance()
   
8. map()
   map applies a function to all the items in an input_list.
9. reduce()
   reduce() function is for computing some computation on a list and returning the result.
   it does the computation all at once not one by one 
   https://www.pinterest.com/ideas/studio-ghibli-autumn-wallpaper/936781700855/


     User Defined function 
    ----------------------
1.  Function argument
2.   Keyword argument
3.   Default argument
4.   arbitary arguments
5.    when we do not know about the number of argument to be passed so we use arbitary arguments .

Recursion
(to do for solving a question) 
   # Base case
   # Formula
   
ex. n x fact(n-1) work till base is 1

Lambda Function or Anonymous function 
its just like the friend function of c++
can we store a function in a variable as a helper function
can we pass function inside function
can we return a function from a function----
 this lead to function programming
 used in pandas
   double = Lambda x:x*2
   print(double(5))
   it creates a function internally in div of type double

   lst=[1,2,3,4,5]
   even_lst=list(filter(lambda x:(x%2==0),lst))
   print(even_lst)

   -----------------------------------------------
   *  Python Functions
Function is a group of related statements that perform a specific task.

Functions help break our program into smaller and modular chunks. As our program grows larger and larger, functions make it more organized and manageable.

It avoids repetition and makes code reusable.

Syntax:
def function_name(parameters):

    """
    Doc String
    """

    Statement(s)
keyword "def" marks the start of function header

Parameters (arguments) through which we pass values to a function. These are optional

A colon(:) to mark the end of funciton header

Doc string describe what the function does. This is optional

"return" statement to return a value from the function. This is optional
Function Call
Once we have defined a function, we can call it from anywhere
Doc String
The first string after the function header is called the docstring and is short for documentation string.

Although optional, documentation is a good programming practice, always document your code

Doc string will be written in triple quotes so that docstring can extend up to multiple lines

return Statement
The return statement is used to exit a function and go back to the place from where it was called.

Syntax:

return [expression]
-> return statement can contain an expression which gets evaluated and the value is returned.

-> if there is no expression in the statement or the return statement itself is not present inside a function, then the function will return None Object

-------------------------------------------
How Function works in Python?
title

Scope and Life Time of Variables
-> Scope of a variable is the portion of a program where the variable is recognized

-> variables defined inside a function is not visible from outside. Hence, they have a local scope.

-> Lifetime of a variable is the period throughout which the variable exits in the memory.

-> The lifetime of variables inside a function is as long as the function executes.

-> Variables are destroyed once we return from the function.

Example:


-------------------------------------------------
#Modules
Modules refer to a file containing Python statements and definitions.

A file containing Python code, for e.g.: abc.py, is called a module and its module name would be "abc".

We use modules to break down large programs into small manageable and organized files. Furthermore, modules provide reusability of code.

We can define our most used functions in a module and import it, instead of copying their definitions into different programs.

How to import a module?
Renaming the module at the time of import(module aliasing)
  test.py
import simplemath as m
   print(m.x)
   m.add(10,20)
   m.product(10,20)

   specifically only add and print value of x so do-->
   from import
   from simplemath import x,add
   print(x)
   add(10,20)

   product(10,20) ---name error:name 'product not defined'

   various possibilities of import
   import modulename
   import module1,mod2,mod3
   from module import member
   from module import member1,member2,member3
   from module import member1 as x
   from module import *

   DSA in Python
   starting from the list,tuple,set,string,dictonaries-->
   then the file handling

----------------------------------------------------------------------------------------------------------------------------------
Lists
Data Structure:

A data structure is a collection of data elements (such as numbers or characters—or even other data structures) that is structured in some way, for example, by numbering the elements. The most basic data structure in Python is the "sequence".

-> List is one of the Sequence Data structure

-> Lists are collection of items (Strings, integers or even other lists)

-> Lists are enclosed in [ ]

-> Each item in the list has an assigned index value.

-> Each item in a list is separated by a comma

-> Lists are mutable, which means they can be changed.

List Creation

[ ]
emptyList = []

lst = ['one', 'two', 'three', 'four'] # list of strings

lst2 = [1, 2, 3, 4] #list of integers

lst3 = [[1, 2], [3, 4]] # list of lists

lst4 = [1, 'ramu', 24, 1.24] # list of different datatypes

print(lst4)

[1, 'ramu', 24, 1.24]
List Length

[ ]
lst = ['one', 'two', 'three', 'four']

#find length of a list
print(len(lst))
4
List Append

[ ]
lst = ['one', 'two', 'three', 'four']

lst.append('five') # append will add the item at the end

print(lst)
['one', 'two', 'three', 'four', 'five']
List Insert

[ ]
#syntax: lst.insert(x, y) 

lst = ['one', 'two', 'four']

lst.insert(2, "three") # will add element y at location x

print(lst)

['one', 'two', 'three', 'four']
List Remove

[ ]
#syntax: lst.remove(x) 

lst = ['one', 'two', 'three', 'four', 'two']

lst.remove('two') #it will remove first occurence of 'two' in a given list

print(lst)
['one', 'three', 'four', 'two']
List Append & Extend

[ ]
lst = ['one', 'two', 'three', 'four']

lst2 = ['five', 'six']

#append 
lst.append(lst2)

print(lst)
['one', 'two', 'three', 'four', ['five', 'six']]

[ ]
lst = ['one', 'two', 'three', 'four']

lst2 = ['five', 'six']

#extend will join the list with list1

lst.extend(lst2)

print(lst)
['one', 'two', 'three', 'four', 'five', 'six']
List Delete

[ ]
#del to remove item based on index position

lst = ['one', 'two', 'three', 'four', 'five']

del lst[1]
print(lst)

#or we can use pop() method
a = lst.pop(1)
print(a)

print(lst)
['one', 'three', 'four', 'five']
three
['one', 'four', 'five']

[ ]
lst = ['one', 'two', 'three', 'four']

#remove an item from list
lst.remove('three')

print(lst)
['one', 'two', 'four']
List realted keywords in Python

[ ]
#keyword 'in' is used to test if an item is in a list
lst = ['one', 'two', 'three', 'four']

if 'two' in lst:
    print('AI')

#keyword 'not' can combined with 'in'
if 'six' not in lst:
    print('ML')
AI
ML
List Reverse

[ ]
#reverse is reverses the entire list

lst = ['one', 'two', 'three', 'four']

lst.reverse()

print(lst)
['four', 'three', 'two', 'one']
List Sorting
The easiest way to sort a List is with the sorted(list) function.

That takes a list and returns a new list with those elements in sorted order.

The original list is not changed.

The sorted() optional argument reverse=True, e.g. sorted(list, reverse=True), makes it sort backwards.


[ ]
#create a list with numbers
numbers = [3, 1, 6, 2, 8]

sorted_lst = sorted(numbers)


print("Sorted list :", sorted_lst)

#original list remain unchanged
print("Original list: ", numbers)
Sorted list : [1, 2, 3, 6, 8]
Original list:  [3, 1, 6, 2, 8]

[ ]
#print a list in reverse sorted order
print("Reverse sorted list :", sorted(numbers, reverse=True))

#orginal list remain unchanged
print("Original list :",  numbers)
Reverse sorted list : [8, 6, 3, 2, 1]
Original list : [3, 1, 6, 2, 8]

[ ]
lst = [1, 20, 5, 5, 4.2]

#sort the list and stored in itself
lst.sort()

# add element 'a' to the list to show an error

print("Sorted list: ", lst)
Sorted list:  [1, 4.2, 5, 5, 20]

[ ]
lst = [1, 20, 'b', 5, 'a']
print(lst.sort()) # sort list with element of different datatypes.


List Having Multiple References

[ ]
lst = [1, 2, 3, 4, 5]
abc = lst
abc.append(6)

#print original list
print("Original list: ", lst)
Original list:  [1, 2, 3, 4, 5, 6]
String Split to create a list

[ ]
#let's take a string

s = "one,two,three,four,five"
slst = s.split(',')
print(slst)
['one', 'two', 'three', 'four', 'five']

[ ]
s = "This is applied AI Course"
split_lst = s.split() # default split is white-character: space or tab
print(split_lst)
['This', 'is', 'applied', 'AI', 'Course']
List Indexing
Each item in the list has an assigned index value starting from 0.

Accessing elements in a list is called indexing.


[ ]
lst = [1, 2, 3, 4]
print(lst[1]) #print second element

#print last element using negative index
print(lst[-2])
2
3
List Slicing
Accessing parts of segments is called slicing.

The key point to remember is that the :end value represents the first value that is not in the selected slice.


[ ]
numbers = [10, 20, 30, 40, 50,60,70,80]

#print all numbers
print(numbers[:]) 

#print from index 0 to index 3
print(numbers[0:4])

[10, 20, 30, 40, 50, 60, 70, 80]
[10, 20, 30, 40]

[ ]
print (numbers)
#print alternate elements in a list
print(numbers[::2])


#print elemnts start from 0 through rest of the list
print(numbers[2::2])

[10, 20, 30, 40, 50, 60, 70, 80]
[10, 30, 50, 70]
[30, 50, 70]
List extend using "+"

[ ]
lst1 = [1, 2, 3, 4]
lst2 = ['varma', 'naveen', 'murali', 'brahma']
new_lst = lst1 + lst2

print(new_lst)
[1, 2, 3, 4, 'varma', 'naveen', 'murali', 'brahma']
List Count

[ ]
numbers = [1, 2, 3, 1, 3, 4, 2, 5]

#frequency of 1 in a list
print(numbers.count(1))

#frequency of 3 in a list
print(numbers.count(3))
2
2
List Looping

[ ]
#loop through a list

lst = ['one', 'two', 'three', 'four']

for ele in lst:
    print(ele)
one
two
three
four
List Comprehensions
List comprehensions provide a concise way to create lists.

Common applications are to make new lists where each element is the result of some operations applied to each member of another sequence or iterable, or to create a subsequence of those elements that satisfy a certain condition.


[ ]
# without list comprehension
squares = []
for i in range(10):
    squares.append(i**2)   #list append
print(squares)
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

[ ]
#using list comprehension
squares = [i**2 for i in range(10)]
print(squares)
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

[ ]
#example

lst = [-10, -20, 10, 20, 50]

#create a new list with values doubled
new_lst = [i*2 for i in lst]
print(new_lst)

#filter the list to exclude negative numbers
new_lst = [i for i in lst if i >= 0]
print(new_lst)


#create a list of tuples like (number, square_of_number)
new_lst = [(i, i**2) for i in range(10)]
print(new_lst)
[-20, -40, 20, 40, 100]
[10, 20, 50]
[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25), (6, 36), (7, 49), (8, 64), (9, 81)]
Nested List Comprehensions

[ ]
#let's suppose we have a matrix

matrix = [
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12]
]

#transpose of a matrix without list comprehension
transposed = []
for i in range(4):
    lst = []
    for row in matrix:
        lst.append(row[i])
    transposed.append(lst)

print(transposed)

[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]

[ ]
#with list comprehension
transposed = [[row[i] for row in matrix] for i in range(4)]
print(transposed)
[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]

[ ]
Colab paid products - Cancel contracts here

----------------------------------------------------------------------------------------------------------------------------------
#Anonymous / Lambda Function
In Python, anonymous function is a function that is defined without a name.

While normal functions are defined using the def keyword, in Python anonymous functions are defined using the lambda keyword.

Lambda functions are used extensively along with built-in functions like filter(), map()

syntax:

lambda arguments: expression

-----------------------------------------------------------------------------------------------------------------------------------
# Package 4/11/2025
Packages are a way of structuring Python’s module namespace by using “dotted module names”.

A directory must contain a file named init.py in order for Python to consider it as a package. This file can be left empty but we generally place the initialization code for that package in this file.

title

importing module from a package
We can import modules from packages using the dot (.) operator.
 The way to import the package in your Python program is :
 # import Game.Image.open 

-----------------------------------------------------------------------------------------------------------------------------------
  Given a list with numbers [2,3,2,4,3,5,6] remove the duplicates but the sequence remains the same----->
  Count how many items contain the letter 'a'
  ram shyam , neha ,rohit = names


  -----------------------------------------------------------------
  11/11/2025
 SET
 Set is mutable but cannot be duplicated 
 We can make set from a list
 Intialize a set using a set() method
 we can add single elemnt using add() method
 add many element using the update() method
 set objects does not support the indexing 

 a particular element can be removed using the discard() method
 if we try to remove any thing that is not there in the set ==>it will give the error then 
 # if we remove the item using the pop() method 
 it will remove the random number (basically the first element of set)
 if we use the clear method it will remove each and every element of the set and thus it will become empty.
 Union of 2 sets is done using (|) operator

set1=(1,2,3,4,5,6)
set2=(6,7,8,9,10)
# print(set1 | set2) 
# print(set1.union(set2))

#for intersection 
# print(set1 & set2)
# print(set1.intersection(set2))

Symmetric difference : set of elements in both set1 and set2 except those that are common in both
# use ^ operator
#-------------------------------------------------------------------------------------------------------------
#operations Done by /on Set#Wrting the set 
s={1,2,3,1,2,4}
#printing the set
print(s)
#----------------------------------------
#printing the type of set
print(type(s))
#----------------------------------------
#Adding the single element
s.add(5)
print (s)
#----------------------------------------
# using update() method we can add many elemnets
s.update([6,7,8,3])
print(s)
#----------------------------------------
#adding the list and set
s.update([6,7,8,3],{9,10})
print(s)
#----------------------------------------
s.discard(4)
print(s)
#----------------------------------------
s.pop()
print(s)
#----------------------------------------
# s.clear()
# print(s)
set1 = {1, 2, 3, 4, 5, 6}
set2 = {6, 7, 8, 9, 10}

print(set1 | set2)     
# union operator

print(set1.union(set2))

#for intersection 
print(set1 & set2)
print(set1.intersection(set2))

# for difference
print(set1 - set2)
print(set1.difference(set2))
#--------------------------------------
#Symmetric difference
print(set1^set2)
print(set1.symmetric_difference(set2))

#Subset
x={"e","a","b","c","d"}
y={"c","d"}
print("set  x is subset of y ?",x.issubset(y))
print("set  y is subset of x ?",y.issubset(x))
----------------------------------------------
 FROZEN sets-->
 the set become immutable and can not be changed and if tried to change then it will throw the error4
 This is the frozen sets in Python 
 
 Syntax : frozenset(iterable_object_name)
Parameter : iterable_object_name

This function accepts iterable object as input parameter.
Return :  Returns an equivalent frozenset object.
 Example:
fruits = frozenset(["apple", "banana", "orange"])
print(fruits) 
fruits.add("cherry")
print(fruits)
--------------------
Demo Exampple
frozenset({'orange', 'apple', 'banana'})
ERROR!
Traceback (most recent call last):
  File "<main.py>", line 3, in <module>
AttributeError: 'frozenset' object has no attribute 'add'